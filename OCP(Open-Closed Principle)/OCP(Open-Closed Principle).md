# OCP(Open-Closed Principle)

### 개요

이번 장에서는 SOLID 중 두 번째 원칙인 Open-Closed Principle에 대해서 알아보겠습니다. 

---

### Open and Closed

OCP는 Open-Closed Principle의 약자로서 뒤에 Open과 Closed에는 목적어가 숨겨져 있습니다. 바로 확장(Extension)과 변경(Modification)입니다. 이 둘을 붙혀 OCP를 다시 읽어보면 **확장에는 열려있고(Open), 수정에는 닫혀있어야 한다(Closed)는 원칙**이 됩니다. 각각의 요소에 대해서 좀더 세부적으로 어떤 뜻을 갖는지 알아보겠습니다.

1. **Open for extension**
    
    Open에서 몰래 숨겨져있던 확장이라는 목적어를 꺼내왔습니다. 그렇다면 숨겨져있던 목적어 ‘확장'은 정확하게 어떤 것을 의미하는 것일까요? 여기서의 확장은 ‘Add a new feature by adding a new type’을 의미합니다. 해석해보면 ‘**새로운 타입을 추가하여 새로운 기능을 추가하는 것**’이죠. 여기서 새로운 타입을 추가한다는 것은 새로운 클래스를 추가하는 것을 의미합니다. 즉 클래스만 추가해도 기능이 추가된다는 것을 의미합니다. 실제 기능에 관련된 코드는 전혀 건들지 않고 말이죠.
    
    앞서 Solid Foundation 파트에서 절차지향과 객체지향의 차이를 알아봤었던 케이스를 기억하시나요? 그 때 입출력 장치가 추가될 때마다 절차지향적인 코드는 장치를 구별하는 플래그와 장치별 메서드를 추가했지만, 객체지향적 코드는 드라이버 클래스만 추가하고 비즈니스 로직(High Level Policy)는 전혀 손대지 않았습니다. 예시에서 작성했던 코드는 OCP 원칙을 잘 지키고 있다고 볼 수 있겠네요.
    
2. **But Closed for modification**
    
    1번처럼 Closed에서도 변경이라는 목적어를 꺼냈습니다. 여기서의 변경은 위의 확장보다는 좀더 간단합니다. 다만 ‘누가' 변경되는 것인지가 중요한데요. 여기서 변경의 대상을 알려주는 문장은 ‘High Level Policy shouldn’t be modified’ 입니다. **상위 레벨 정책은 수정되서는 안된다**는 것이죠. 여기서 상위 레벨의 정책은 Solid Foundation 코드의 copy 메서드가 그 예시라고 볼 수 있습니다.
    

---

### OCP의 장점

OCP를 통해 얻을 수 있는 장점들은 무엇이 있을까요?

1. **Easy to change the behavior of the module without having to change the source code of that module**
    
    1번에서 언급한 점입니다. 실질적으로 동작하는 비즈니스 로직, 즉 소스코드의 변경없이 모듈의 행동을 쉽게 바꿀 수 있다는 것입니다. 하지만 이것은 앞서 확인했던 것처럼 단순히 절차적인 코드를 통해서는 불가능합니다. 객체지향적인 디자인이 들어가야만 하죠. 
    
    여기서 필요한 것이 바로 **Abstraction and Inversion** 입니다. 상위 레벨과 하위 레벨의 모듈 사이에 absract interfcae를 끼워넣어서 **상위 레벨의 비즈니스 로직이 인터페이스에만 의존**하게 만들고 **하위 레벨이 이를 구현**하도록 만들어야 합니다. 즉 확장이 필요한 행위에 대해서 추상화를 진행하는 것이 핵심입니다. 
    

---

### Is This Possible?

그런데 문제가 있습니다. 과연 OCP를 준수하면 완벽하게 수정을 제거할 수 있을까요? 물론 이론적으로 가능합니다. 하지만 현실적으로는 굉장히 비실용적입니다. 그 이유는 바로 **Crystal ball problem** 입니다. 여기서 크리스탈 볼은 미래를 볼 수 있는 마법 수정구를 말합니다. 확장을 위해 인터페이스를 미리 준비해놓는다는 것이 미래를 볼 수 있는 크리스탈 볼이 있지 않은 이상 불가능하다는 것입니다. 이는 설계 수준에서 낭비가 심하고 심지어 불가능하며 만약 가능해더라도 너무 복잡해진다는 문제가 있습니다. 

또한 만약 고객이 설계 과정에서 고려되지 않았던 새로운 기능을 요구하면 대책이 없어진다는 문제가 존재합니다. 그리고 우린 항상 Unknown Unknowns를 맞닥뜨립니다. 아무리 잘 준비해놔도 고객은 항상 준비하지 못한 부분에 대한 기능의 추가/변경을 요구합니다. 그렇다면 앞으로 확장이 어디에 필요할 지 알아야만 OCP가 가능한 것일까요?

---

### Two solutions

우리에겐 미래를 볼 수 있는 수정볼도 없고, 그렇다고 타임머신이 있는 것도 아닙니다. 심지어 있다고 해도 매번 타임머신을 타면서 개발을 할 순 없죠. 그렇다면 예지가 불가능한 문제, 크리스탈 볼을 어떻게 제거해야 할까요?

1. **Big Design Up Front(BDUF)**
    
    BDUF는 고객의 요구사항을 치밀하게 분석해서 최대한 많은 영역을 고려하고 반영할 수 있는 도메인 모델을 만드는 것입니다. 하지만 사실 위에서도 말했듯 고객은 역시 자신이 만져보기 전까지 자신이 무엇을 원하는지 모릅니다. 따라서 완성이 되고 나면 결국 만든 것들의 대부분은 필요치 않는 추상화같은 무겁고 복잡한 쓰레기가 되버립니다. 또한 추상화는 강력함과 비용이 비례합니다. 강력한 만큼 비용도 크다는 의미죠. 여기서 비용은 추상화의 적용으로 인한 코드의 직관적인 이해가 어려워진다는 것을 의미합니다. 따라서 이를 개선하기 위해 다른 접근 법이 등장했습니다.
    
2. **Agile Design**
    
    애자일은 BDUF가 너무 거대하고 각 실행에 리스크가 너무 큰 점을 개선하기 위해 등장했습니다. 애자일은 먼저 실행 가능한 결정을 내리고, 최대한 고객의 요구사항을 빠르게 끌어낼 수 있는 가장 단순한 일을 수행합니다. BDUF는 고객이 어떤 걸 원할지 미리 머리를 싸매고 앉아 고민했지만, 애자일은 애초에 불확실한 미래를 고민하는 것 자체를 낭비라고 생각합니다. 대신 고객이 원하는 것만 만들어서 빠르게 전달하는 스탠스를 취합니다.
    
    빠르게 전달하고 나면 고객은 그제서야 자신이 어떤 요구사항에 변경이 필요한지를 인식하고 요구하게 되고 우린 미리 예측할 필요없이 어떤 변경이 필요한지 알게 되는 것이죠. 여기서 명심해야할 것은 애자일은 계획을 세우지 말라는 얘기가 아니라는 것입니다. 우리가 행할 수 있을만큼의 계획만 세우자는 것이 핵심입니다.
    

---

### 마치며

- OCP가 완벽해지려면 크리스탈 볼(미래 예측)이 필요하다
- 그렇다고 희망이 없는 것도 아니다
- 피드백, 리팩토링에 기반한 주기적인 개선 작업을 통해 OCP에 충분히 잘 순응하는 시스템을 만들 수 있다

---

### 기타

- 이렇듯 타입 객체는 추가되지 않지만 기능만 추가된다면 절차지향적 패러다임이 더 맞다
- 스프링을 쓰는 이유는?
    - DI를 편하게 해주니까
    - 하위 레벨이 어떻게 선택될 지를 DI 컨테이너와 IoC를 통해 가능케 해준다.
    - PSA, Potable Service Abstraction
- 확장이 필요한 행위를 Abstraction하자.
- 리팩토링이라는 것은 객체지향의 원칙에 맞춰 설계는 일이다
    - 마틴 파울러 리팩토링 책을 봤다고 할 수 있는게 아니다
    - 결국 중요한 것은 **객체지향적인 설계를 만들 수 있는 능력**이다