# SRP

- Responsibility
    - 메서드 개수의 증가가 책임의 수 증가를 뜻하지는 않는다.
        - ex. EmployeeImpl에서 save, findById() 은 같은 **부류**다. calculatePay와는 다른 부류다.
    - 부류라는 것은 뭔가?
        - 부류는 메서드를 사용하는 Client다.
        - 즉 메서드를 누가 사용하는가에 따라 결정된다
        - 누가 변경을 유발하는가? save() 로직의 변경이 필요하다면 누구 때문에 필요한건가? 누구로 카테고라이징이 가능하다.
    - 즉 여기서 말하는 ‘책임'이란 **변경의 근원**이다.
        - 변경의 원인이 같다면 동일한 책임이다.
        - 클라이언트는 그들이 수행하는 롤에 따라 나눠진다.
- Two value of SW
    - Primary
        - 지속적으로 변화하는 요구사항을 수용할 수 있는가?
    - Secondary
        - 현재 SW가 현재 사용자의 현재 요구사항을 만족하는가?
    - 우리는 주로 Secondary를 Primary로 착각한다.
- 책임이 많다면 어떤 문제가 생길까?
    - Collision(충돌)
        - Employee 클래스에 책임이 너무 많다면 클래스를 사용하는 클라이언트들이 변경을 요구할 때 그 클래스만 변경된다.
        - 이것은 **동일 모듈이 여러 요구사항에 의해 변경**된다는 것이다. 이것 때문에 Merge에서 **충돌**이 일어난다.
    - Fan out
        - Employee 클래스가 너무 많은 API를 사용하면 이 API 중 하나만 변경되도 클래스가 변경된다.
        - 즉 너무 변경에 너무 예민하다.
        - Employee 클래스를 사용하는 클래스, 클라이언트 역시 더 민감해진다.
- 핵심은 하나의 클래스는 하나의 **변경 사유**를 가져야 한다.
    - 여기서 변경 사유는 뭐다? 액터다.
    - 액터가 뭐다? 이 클래스를 사용하는 클라이언트들이다.
    - 하나의 클래스는 한 부류의 액터들만 서브해야한다.
    - 같은 부류로 분류되는 클라이언트(액터)들만 자신을 사용할 수 있도록 만들어야 한다.
- 그렇다면 이렇게 만들려면 어떤 방법이 있을까?
    - Inverted Dependencies
        - 클래스를 인터페이스와 클래스로 분리시키자
        - 메서드들을 하나의 인터페이스로 다 모으자
    - Extract Classes
        - Emplyee를 예시로 들면 3개의 책임을 3개의 클래스로 분리하자
        - Employee 개념이 각각 3개의 조각으로 분리되어 있다
    - Inverted Dependencies & Extract Classes
        - Inverted Dependencies에서 하나로 모은 인터페이스를 세개로 나누자
        - 그리고 이를 각각 구현하면 위 두개에서 갖던 문제를 해결할 수 있다.
        - 
    - Facade(파사드)
        - 어디에 구현이 되어있는지 찾기 쉽게
        - 파사드가 모든 책임을 하나에 모으고 각 책임을 갖는 클래스에 위임해주는 방식
    - Interface Segregation
        - 위애서처럼 3개의 인터페이스로 나누고 하나의 클래스로 구현하는 방식
        - 액터들은 실제 구현 클래스와 의존성이 없지만 어디에 구현됐는지 찾기 어렵다
- 리팩토링 역량을 기르기 위해선?
    - 단위 테스트
    - 좋은 아키텍쳐를 만들기 위해서 리팩토링을 많이 시도해보자